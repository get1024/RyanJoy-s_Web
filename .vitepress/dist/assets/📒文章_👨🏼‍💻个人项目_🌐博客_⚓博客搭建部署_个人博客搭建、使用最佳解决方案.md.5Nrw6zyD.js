import{_ as d,B as r,c as l,o as i,j as s,G as e,a3 as g,a as c}from"./chunks/framework.DFbhKqot.js";const p="/assets/2025-01-31_17-57-56.CUP-T8xE.gif",b="/assets/20250131221726.Cz4y-two.png",h="/assets/20250131221649.M_ZbCfni.png",u="/assets/20250131223328.C37Pxqxg.png",k="/assets/20250131223402.coseBB_-.png",m="/assets/20250131223459.KEUWas_M.png",y="/assets/20250131223526.B7sLLr3a.png",_="/assets/20250131225400.BSCjEnwq.png",f="/assets/20250131225642.Nh4Pfs9P.png",M="/assets/20250131225944.0fF5JaLj.png",T="/assets/20250131230508.CPHVmrcg.png",V="/assets/20250131231435.DbatGjII.png",w="/assets/20250131232228.CC7kxpbY.png",x="/assets/20250131232434.Cm87pnkl.png",v="/assets/20250131233858.C-DXwjBw.png",G=JSON.parse('{"title":"个人博客搭建、使用最佳解决方案","description":"","frontmatter":{"title":"个人博客搭建、使用最佳解决方案","createAt":"2024-03-21T18:56:43.000Z","updateAt":"2025-02-05T11:06:48.000Z","tags":["博客","解决方案"]},"headers":[],"relativePath":"📒文章/👨🏼‍💻个人项目/🌐博客/⚓博客搭建部署/个人博客搭建、使用最佳解决方案.md","filePath":"📒文章/👨🏼‍💻个人项目/🌐博客/⚓博客搭建部署/个人博客搭建、使用最佳解决方案.md","lastUpdated":1738768953000}'),U={name:"📒文章/👨🏼‍💻个人项目/🌐博客/⚓博客搭建部署/个人博客搭建、使用最佳解决方案.md"};function J(R,t,P,j,E,Q){const a=r("ArticleMetadata"),o=r("NolebaseGitContributors"),n=r("NolebaseGitChangelog");return i(),l("div",{"data-pagefind-body":!0,"data-pagefind-meta":"base64:JTdCJTIydGl0bGUlMjIlM0ElMjIlRTQlQjglQUElRTQlQkElQkElRTUlOEQlOUElRTUlQUUlQTIlRTYlOTAlQUQlRTUlQkIlQkElRTMlODAlODElRTQlQkQlQkYlRTclOTQlQTglRTYlOUMlODAlRTQlQkQlQjMlRTglQTclQTMlRTUlODYlQjMlRTYlOTYlQjklRTYlQTElODglMjIlMkMlMjJjcmVhdGVBdCUyMiUzQSUyMjIwMjQtMDMtMjFUMTglM0E1NiUzQTQzLjAwMFolMjIlMkMlMjJ1cGRhdGVBdCUyMiUzQSUyMjIwMjUtMDItMDVUMTElM0EwNiUzQTQ4LjAwMFolMjIlMkMlMjJ0YWdzJTIyJTNBJTVCJTIyJUU1JThEJTlBJUU1JUFFJUEyJTIyJTJDJTIyJUU4JUE3JUEzJUU1JTg2JUIzJUU2JTk2JUI5JUU2JUExJTg4JTIyJTVEJTJDJTIyZGF0ZSUyMiUzQTE3Mzg3Njg5NTMwMDAlN0Q="},[t[0]||(t[0]=s("h1",{id:"个人博客搭建、使用最佳解决方案",tabindex:"-1"},[c("个人博客搭建、使用最佳解决方案 "),s("a",{class:"header-anchor",href:"#个人博客搭建、使用最佳解决方案","aria-label":'Permalink to "个人博客搭建、使用最佳解决方案"'},"​")],-1)),e(a),t[1]||(t[1]=g('<h2 id="ssg-选择" tabindex="-1">SSG 选择 <a class="header-anchor" href="#ssg-选择" aria-label="Permalink to &quot;SSG 选择&quot;">​</a></h2><p>目前用户较多的有 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noreferrer">Hexo</a>，<a href="https://gohugo.io/" target="_blank" rel="noreferrer">Hugo</a>，<a href="https://www.gatsbyjs.com/" target="_blank" rel="noreferrer">Gatsby</a>，<a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noreferrer">VuePress</a>，<a href="https://vitepress.dev/zh/" target="_blank" rel="noreferrer">VitePress</a>，<a href="https://jekyllrb.com/" target="_blank" rel="noreferrer">Jekyll</a>。另外还有 <a href="https://getpelican.com/" target="_blank" rel="noreferrer">Pelican</a>，<a href="https://middlemanapp.com/" target="_blank" rel="noreferrer">Middleman</a>，<a href="https://www.mkdocs.org/" target="_blank" rel="noreferrer">MkDocs</a>，<a href="https://docsify.js.org/#/" target="_blank" rel="noreferrer">docsify</a> ，<a href="https://www.gitbook.com/" target="_blank" rel="noreferrer">GitBook</a>等……</p><p>毫无疑问，如果你正在看这篇文档，说明你和我刚开始搭建博客时有一样的忧虑。</p><h3 id="主流生成器汇总对比" tabindex="-1">主流生成器汇总对比 <a class="header-anchor" href="#主流生成器汇总对比" aria-label="Permalink to &quot;主流生成器汇总对比&quot;">​</a></h3><p>下面给出一些<span class="marker-evy">主流生成器</span>在我<strong>主观层面的对比分析</strong>：</p><div class="custom-table-container"><table><thead><tr><th>工具</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>Hexo</strong></td><td>- 基于 Node. js，安装部署较方便<br>- 插件和主题丰富，社区活跃，适合博客和个人站点</td><td>- 构建速度较慢，随着内容增多可能下降<br>- 依赖 Node 生态，部分插件维护不够活跃，升级时可能遇到兼容性问题</td></tr><tr><td><strong>Hugo</strong></td><td>- 极速构建，超快速度（Go 语言驱动）<br>- 单二进制文件，部署简单- 内置丰富功能，适合大规模内容网站</td><td>- 主题较少<br>- 模板语法较特殊，学习成本较高<br>- 部分高级定制需求可能受到框架限制</td></tr><tr><td><strong>Gatsby</strong></td><td>- 基于 React，适合构建复杂应用<br>- 丰富的插件系统和 GraphQL 数据层<br>- 支持 PWA、图像优化等特性</td><td>- 构建速度慢，内容多时性能可能成为瓶颈<br>- 配置复杂，学习曲线陡峭，需要熟悉 React 和 GraphQL</td></tr><tr><td><strong>VuePress</strong></td><td>- 以 Vue 为核心，配置简单，专注于文档站点<br>- 默认主题简洁美观，支持热重载<br>- Markdown 与 Vue 组件无缝结合</td><td>- V1 版本构建速度较慢<br>- 功能主要面向文档，复杂网站可能不够灵活<br>- 社区插件和生态相对 Gatsby 等略逊</td></tr><tr><td><strong><code>VitePress</code></strong></td><td>- 基于 Vite 和 Vue 3，极速开发体验（快速 HMR，启动速度快）<br>- 体积轻量、配置简单，适合文档和博客站点<br>- 内置 Markdown 支持，可嵌入 Vue 组件，优化文档阅读体验<br>- 现代化技术栈</td><td>- 插件生态尚在初期，扩展和高级需求可能需自行开发<br>- 主题定制成本较高，定制化能力受限<br>- 社区规模较小，官方文档和案例尚不丰富</td></tr><tr><td><strong>Jekyll</strong></td><td>- 深度整合 GitHub Pages，官方支持<br>- 社区成熟，插件丰富<br>- 适合博客和文档站点</td><td>- 依赖 Ruby 环境，对初学者不够友好<br>- 当内容较多时构建速度较慢</td></tr><tr><td><strong>Pelican</strong></td><td>- 基于 Python，适合 Python 开发者<br>- 支持 Markdown 与 reStructuredText，灵活性较高</td><td>- 主题和插件资源较少<br>- 社区活跃度较低</td></tr><tr><td><strong>Middleman</strong></td><td>- 灵活定制，适合开发个性化网站<br>- 依托 Ruby 生态，有较强的定制能力</td><td>- 相对过时，社区活跃度低<br>- 需要对 Ruby 环境有较深入了解，入门门槛较高</td></tr><tr><td><strong>MkDocs</strong></td><td>- 专注文档站点，配置简单，易于上手<br>- 基于 Python 开发，内置美观主题和搜索功能</td><td>- 功能较为单一，不适合博客或复杂网站<br>- 定制化程度有限</td></tr><tr><td><strong>docsify</strong></td><td>- 无需预生成静态 HTML，直接在浏览器中渲染 Markdown<br>- 上手简单，零构建步骤，适合轻量级文档展示</td><td>- 客户端渲染对 SEO 不友好<br>- 大型项目首屏加载可能存在性能问题</td></tr><tr><td><strong>GitBook</strong></td><td>- 专注于交互式文档编写与团队协作，在线编辑体验好<br>- 集成版本控制与多人协作工具</td><td>- 商业化转型后开源功能受限，部分功能收费</td></tr><tr><td><strong>Docusaurus</strong></td><td>- 基于 React，专注于开源文档和博客<br>- 内置多语言和版本控制支持，社区活跃，适合项目文档</td><td>- 默认风格固定，定制成本较高<br>- 对于非 React 开发者来说，上手可能存在一定门槛</td></tr><tr><td><strong>Sphinx</strong></td><td>- 技术文档标准工具，支持 LaTeX 排版</td><td>- 配置复杂，学习曲线陡峭</td></tr><tr><td><strong>Eleventy (11ty)</strong></td><td>- 无框架依赖，灵活轻量- 支持多种模板语言（如 Nunjucks、Liquid、Handlebars 等），构建速度快，配置自由度高- 社区发展迅速</td><td>- 需要自行整合工具链<br>- 生态尚在完善，部分高级功能需自行开发- 对初学者来说可能因过于自由而增加学习曲线</td></tr><tr><td><strong>Next.js</strong></td><td>- 同时支持静态生成与服务端渲染，灵活性极高- 基于 React，生态系统完善- 适合构建复杂、交互丰富的网站</td><td>- 配置较复杂，学习曲线陡峭<br>- 对于纯静态站点来说可能显得臃肿</td></tr><tr><td><strong>Nuxt.js</strong></td><td>- 基于 Vue，支持 SSR 和 SSG，配置友好<br>- 社区活跃、文档完善<br>- 适合 Vue 用户构建复杂站点</td><td>- 对于仅需简单静态站点的项目可能过于复杂<br>- 高定制需求时插件配置和管理较复杂</td></tr><tr><td><strong>Zola</strong></td><td>- 基于 Rust，构建速度极快<br>- 部署简单，仅需一个二进制文件<br>- 适合对性能和构建效率要求极高的项目</td><td>- 生态较小，插件和模板资源有限<br>- 模板和功能较为基础，高级定制可能需要自行扩展</td></tr><tr><td><strong>Metalsmith</strong></td><td>- 极简核心，完全依赖插件实现功能，灵活可定制<br>- 适合需要精细控制构建过程的开发者</td><td>- 插件配置和管理较繁琐<br>- 相较于现代工具，生态和文档支持可能不足</td></tr><tr><td><strong>Astro</strong></td><td>- 组件化设计，支持混合使用多种前端框架<br>- 面向现代 Web 开发趋势</td><td>- 概念较新，文档和案例仍需进一步完善</td></tr></tbody></table></div><h3 id="感到十分头疼不知作何选择-感到花样太多难以做出决定" tabindex="-1">感到十分头疼不知作何选择 ？感到花样太多难以做出决定？ <a class="header-anchor" href="#感到十分头疼不知作何选择-感到花样太多难以做出决定" aria-label="Permalink to &quot;感到十分头疼不知作何选择 ？感到花样太多难以做出决定？&quot;">​</a></h3><p>我在上述表格的基础上，删除了具有以下特点的生成器：</p><ul><li>用户人数少；</li><li>社区不活跃；</li><li>技术相对不新颖；</li></ul><p>那么相对而言，较为优选的生成器就汇总出来了</p><div class="custom-table-container"><table><thead><tr><th>工具</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>Hexo</strong></td><td>- 基于 Node.js，安装部署较方便<br>- 插件和主题丰富，社区活跃，适合博客和个人站点</td><td>- 构建速度较慢，内容增多时可能下降<br>- 部分插件维护不够活跃，升级时可能遇到兼容性问题</td></tr><tr><td><strong>Hugo</strong></td><td>- 极速构建（Go 语言驱动）<br>- 单二进制文件，部署简单<br>- 内置丰富功能，适合大规模内容网站</td><td>- 主题较少<br>- 模板语法特殊，上手学习成本较高<br>- 部分高级定制需求可能受到框架限制</td></tr><tr><td><strong>Gatsby</strong></td><td>- 基于 React，适合构建复杂应用<br>- 丰富的插件系统和 GraphQL 数据层<br>- 支持 PWA、图像优化等特性</td><td>- 构建速度慢，内容多时性能可能成为瓶颈<br>- 配置复杂，学习曲线陡峭，需要熟悉 React 和 GraphQL</td></tr><tr><td><strong>VuePress</strong></td><td>- 以 Vue 为核心，配置简单，专注于文档站点<br>- 默认主题简洁美观，支持热重载<br>- Markdown 与 Vue 组件无缝结合</td><td>- V1 构建速度较慢<br>- 功能主要面向文档，复杂网站可能不够灵活<br>- 社区插件和生态相对 Gatsby 等略逊</td></tr><tr><td><strong><code>VitePress</code></strong></td><td>- 基于 Vite 和 Vue 3，极速开发体验（快速 HMR，启动速度快）<br>- 体积轻量、配置简单，适合文档和博客站点<br>- 内置 Markdown 支持，可嵌入 Vue 组件，优化文档阅读体验<br>- 现代化技术栈</td><td>- 插件生态尚处初期，扩展和高级需求可能需自行开发<br>- 主题定制成本较高，定制化能力受限<br>- 社区规模相对较小，相关案例和资料仍在积累</td></tr><tr><td><strong>Jekyll</strong></td><td>- 深度整合 GitHub Pages，官方支持<br>- 社区成熟，插件丰富，适合博客和文档站点</td><td>- 依赖 Ruby 环境，对初学者可能不够友好<br>- 当内容较多时构建速度较慢</td></tr><tr><td><strong>Docusaurus</strong></td><td>- 基于 React，专注于开源文档和博客<br>- 内置多语言和版本控制支持，适合项目文档<br>- 社区活跃、维护良好</td><td>- 默认风格固定，定制成本较高<br>- 对非 React 开发者来说，上手可能存在一定门槛</td></tr><tr><td><strong>Eleventy</strong></td><td>- 无框架依赖，灵活轻量<br>- 支持多种模板语言（如 Nunjucks、Liquid、Handlebars 等），构建速度快，配置自由度高<br>- 社区发展迅速</td><td>- 需要自行整合工具链<br>- 生态尚在完善，部分高级功能需自行开发<br>- 对初学者来说可能因过于自由而增加学习曲线</td></tr><tr><td><strong>Next.js</strong></td><td>- 同时支持静态生成与服务端渲染，灵活性极高<br>- 基于 React，生态系统完善<br>- 适合构建复杂、交互丰富的网站</td><td>- 配置较复杂，学习曲线陡峭<br>- 对于单纯的静态站点来说可能显得臃肿</td></tr><tr><td><strong>Nuxt.js</strong></td><td>- 基于 Vue，支持 SSR 与 SSG，配置友好<br>- 社区活跃、文档完善<br>- 适合 Vue 用户构建复杂站点</td><td>- 对于仅需简单静态站点的项目可能显得复杂<br>- 高定制需求时插件配置和管理可能较为繁琐</td></tr><tr><td><strong>Astro</strong></td><td>- 组件化设计，支持混合使用多种前端框架<br>- 面向现代 Web 开发趋势，适合构建性能优异的静态站点</td><td>- 概念较新，部分文档和案例仍需进一步完善</td></tr></tbody></table></div><h3 id="进一步贴切——文档性站点需求" tabindex="-1">进一步贴切——文档性站点需求 <a class="header-anchor" href="#进一步贴切——文档性站点需求" aria-label="Permalink to &quot;进一步贴切——文档性站点需求&quot;">​</a></h3><p>考虑到所谓「博客」也是文字性内容居多，对于 <strong>样式、美化</strong> 我相信不是我们博客人做电子笔记或者说电子书的初心所在。</p><p class="marker-underline">所以，这里进一步筛选出定位在「文档性站点」的生成器。</p><div class="custom-table-container"><table><thead><tr><th>工具</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>VuePress</strong></td><td>- 以 Vue 为核心，配置简单，专注于文档站点<br>- 默认主题简洁美观，支持热重载<br>- Markdown 与 Vue 组件无缝结合</td><td>- V1 构建速度较慢<br>- 功能主要面向文档，复杂网站可能不够灵活<br>- 社区插件和生态相对 Gatsby 等略逊</td></tr><tr><td><strong><code>VitePress</code></strong></td><td>- 基于 Vite 和 Vue 3，极速开发体验（快速 HMR，启动速度快）<br>- 体积轻量、配置简单，适合文档和博客站点<br>- 内置 Markdown 支持，可嵌入 Vue 组件，优化文档阅读体验<br>- 现代化技术栈</td><td>- 插件生态尚处初期，扩展和高级需求可能需自行开发<br>- 主题定制成本较高，定制化能力受限<br>- 社区规模相对较小，相关案例和资料仍在积累</td></tr><tr><td><strong>Jekyll</strong></td><td>- 深度整合 GitHub Pages，官方支持<br>- 社区成熟，插件丰富，适合博客和文档站点</td><td>- 依赖 Ruby 环境，对初学者可能不够友好<br>- 当内容较多时构建速度较慢</td></tr><tr><td><strong>Docusaurus</strong></td><td>- 基于 React，专注于开源文档和博客<br>- 内置多语言和版本控制支持，适合项目文档<br>- 社区活跃、维护良好</td><td>- 默认风格固定，定制成本较高<br>- 对非 React 开发者来说，上手可能存在一定门槛</td></tr></tbody></table></div><h3 id="最终方案敲定" tabindex="-1">最终方案敲定 <a class="header-anchor" href="#最终方案敲定" aria-label="Permalink to &quot;最终方案敲定&quot;">​</a></h3><p>在这里呢，显而易见我的选择是 <code>VitePress</code> ，吸引我的地方：一是它样式较为正式，颇具「项目说明书」「Wiki 文档」「使用手册」「项目文书」这样的特点；二是结构简单，布局清晰；三是用户群体愈来愈多，方便交流。</p><p>当然，有可能你很喜欢「精美的样式」、「炫酷的动效」、「高度自定义的主题」、「别具一格的站点风格」，那么 <code>Vitepress</code> 一定不是你的最终选择。</p><p>为了帮你快速做出抉择，这里给出以下推荐：</p><ol><li><strong>新手入门</strong>：从 <strong>Hexo/Jekyll</strong> 开始，依赖成熟生态降低学习成本。</li><li><strong>文档优先</strong>： <ul><li>Vue 技术栈选 <strong>VitePress</strong></li><li>React 技术栈选 <strong>Docusaurus</strong></li><li>Python 项目选 <strong>MkDocs/Sphinx</strong>。</li></ul></li><li><strong>企业级应用</strong>：结合框架能力（如 <strong>Nuxt.js / Next.js</strong>) 和 Headless CMS</li><li><strong>极简主义</strong>：追求构建速度用 <strong>Hugo/Zola</strong>，灵活性用 <strong>Eleventy</strong></li><li><strong>交互丰富站点</strong>：<strong>Gatsby</strong>（React）或 <strong>Astro</strong>（混合框架）。</li></ol><p>相信上述内容一定对你的博客搭建技术选型有所帮助，选择你喜欢的进行第一次搭建吧！</p><div class="tip custom-block"><p class="custom-block-title">一些忠告</p><p>博客，重点是内容产出，至于真正选什么生成器都是次要的，多看一些私人博客站点，你自会有所抉择。</p></div><h2 id="博客板块设置" tabindex="-1">博客板块设置 <a class="header-anchor" href="#博客板块设置" aria-label="Permalink to &quot;博客板块设置&quot;">​</a></h2><ol><li><strong>🏠首页</strong>：这是用户访问博客时首先看到的页面。它应该包含博客的基本介绍、分类导航以及关于博主或博客的简要介绍。</li><li><strong>📒文章</strong>：这是博客系统的核心板块，用于展示博主的文章。可以进一步细分为不同的分类或标签，方便用户根据兴趣浏览。 <ul><li><strong>生活技能</strong></li><li><strong>个人项目</strong></li><li><strong>操作系统</strong></li><li><strong>专业技能</strong></li><li><strong>反思和总结</strong></li><li><strong>实用工具</strong></li></ul></li><li><strong>关于我</strong>：这个板块可以介绍博主的基本信息、兴趣爱好、职业背景等，有助于读者更好地了解博主和博客的定位。</li><li><strong>归档/历史文章</strong>：按照时间顺序或主题分类展示过去的文章，方便读者查找和回顾。</li><li><strong>评论区</strong>：提供留言功能，方便读者与博主互动，提出问题或建议。</li><li><s><strong>友情链接/推荐资源</strong>：列出其他相关博客或网站的链接，可以扩大博主的社交网络，也可以为读者提供更多有价值的信息。</s></li><li><strong>搜索功能</strong>：提供搜索功能，方便用户快速找到感兴趣的内容。</li></ol><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><p>这里比较推荐的使用方案是 <code>Obsidian</code> ➕ <code>Vitepress</code> 的方案。例如我现在在这里进行文档编写，在 VScode 里面进行版本控制和代码提交。</p><p><img src="'+p+'" alt="" loading="lazy"></p><p>这里的使用方案也是我在踩了无数的坑、重构了无数次博客布局后摸索出来的，下面给大家做一下分享。</p><h3 id="obsidian配置" tabindex="-1">Obsidian配置 <a class="header-anchor" href="#obsidian配置" aria-label="Permalink to &quot;Obsidian配置&quot;">​</a></h3><h4 id="文件与链接" tabindex="-1">文件与链接 <a class="header-anchor" href="#文件与链接" aria-label="Permalink to &quot;文件与链接&quot;">​</a></h4><p>Obsidian 提供 Wiki 双链 ( <code>[[双链]]</code> ) 和原生 <code>Markdown链接</code> 的两种链接方式，Wiki 双链在 Obsidian 使用当然是十分顺滑自然的，但是这一设置显著削弱了博客系统的<strong>跨平台性和健壮性</strong>。</p><p>在最开始我为了解决这一问题，采取了大佬 <a href="https://github.com/nekomeowww" target="_blank" rel="noreferrer">@nekomeowww (Neko)</a> 的插件方案： <a href="https://nolebase-integrations.ayaka.io/pages/zh-CN/integrations/markdown-it-bi-directional-links/" target="_blank" rel="noreferrer">双向链接 | Nólëbase 集成</a> 来解决。在一开始，确实拥有了不错的体验：</p><ul><li>在 Obsidian 编写文档创建链接方便；</li><li><code>Vitepress</code> 在插件的作用下也能成功识别并渲染</li><li>……</li></ul><p><span class="marker-evy">但是也存在问题</span>。</p><p>我们在写文档的时候，为了保证成品效果，有时候只看 Obsidian 端的效果是不准确的，这里以当前界面为示例，如图：</p><div class="custom-table-container"><table><thead><tr><th style="text-align:center;"><strong>Obsidian</strong></th><th style="text-align:center;"><strong>Vitepress</strong>渲染结果</th></tr></thead><tbody><tr><td style="text-align:center;"><img src="'+b+'" alt="" loading="lazy"></td><td style="text-align:center;"><img src="'+h+'" alt="" loading="lazy"></td></tr></tbody></table></div><p class="marker-underline">所以我们会不停的切换到浏览器页面查看前端渲染完成的效果。</p><p>但这就引出了前文提到的问题： <a href="https://nolebase-integrations.ayaka.io/pages/zh-CN/integrations/markdown-it-bi-directional-links/" target="_blank" rel="noreferrer">双向链接 | Nólëbase 集成</a> 查看方案只能保证 <code>Vitepress</code> 在部署到服务器上以后我们看到的链接引用是正确的，但是如果我们直接在 <code>Markdown</code> 文档中使用 <code>![[]]</code> 写法，只会在 Obsidian 端看到效果，而前端 <code>dev</code> 界面未能成功渲染。如图所示：</p><div class="custom-table-container"><table><thead><tr><th><strong>引用方式</strong></th><th style="text-align:center;"><strong>Obsidian</strong></th><th style="text-align:center;"><code>Vitepress</code> 前端 DEV</th></tr></thead><tbody><tr><td><code>![[assets/个人博客搭建、使用最佳解决方案/RyanJoy.jpg]]</code></td><td style="text-align:center;"><img src="'+u+'" alt="" loading="lazy"></td><td style="text-align:center;"><img src="'+k+'" alt="" loading="lazy"></td></tr><tr><td><code>![](assets/个人博客搭建、使用最佳解决方案/RyanJoy.jpg)</code></td><td style="text-align:center;"><img src="'+m+'" alt="" loading="lazy"></td><td style="text-align:center;"><img src="'+y+'" alt="" loading="lazy"></td></tr></tbody></table></div><p class="marker-fakeTitle">所以为了考虑到更加适合开发的情形，这里我换回了原生 <code>Markdown链接</code> 的方案。</p><p>在此基础之上，为了优化开发体验、增强博客系统健壮性，这里又增添了几个插件：</p><ul><li><p><a href="obsidian://show-plugin?id=obsidian-custom-attachment-location" target="_blank" rel="noreferrer">Custom Attachment Location</a>：一个自动修改附件名称、存储位置的插件。</p><p>插件配置如下：</p><p><img src="'+_+'" alt="" loading="lazy"></p><p>系统配置如下：</p><p><img src="'+f+'" alt="" loading="lazy"></p><p>在这样配置之后，每次 <code>粘贴</code> 图片到编辑区域中，插件便会自动的给图片命名，并把其放入 <code>./assets/${filename}</code> 路径中。如图所示：</p><p><img src="'+M+'" alt="" loading="lazy"></p><p>安装之后，「已经存在的图片」不会自动被处理。如果你希望全部图片都按照上述图片所示的结构存储，执行以下步骤：</p><ol><li><p>在 Obsidian 编辑页面，按 <code>Ctrl+p</code> ，换出命令面板；</p></li><li><p>在命令面板输入 <code>custom attachment location</code> ，出现选项：</p><p><img src="'+T+'" alt="" loading="lazy"></p><p>第一个是只对<strong>当前文件</strong>的附件进行自动化处理；第二个是对<strong>整个仓库</strong>的附件进行自动化处理；第三个是对<strong>当前文件所在文件夹</strong>的附件进行自动化处理。选择你想要处理的范围即可。</p><p><strong>这里我直接选了第二个。</strong></p><div class="warning custom-block"><p class="custom-block-title">注意！！！</p><p>数据无价！记得提前备份再进行操作！</p></div><p>执行第二个命令之后，会发现原本存储图片的位置已经自动清除，现在所有图片已经被移动到 <span class="marker-evy"><strong>指定配置</strong></span> 的位置</p></li><li><p>后续就基本不再会使用「步骤 2」的命令了，你<code>粘贴</code>的图片会自动被处理。</p></li></ol></li><li><p><a href="obsidian://show-plugin?id=obsidian-link-converter" target="_blank" rel="noreferrer">Obsidian Link Converter</a>：一个自动扫描全局链接的插件，把原本链接转化为你所指定的形式。</p><p>插件配置如下：</p><p><img src="'+V+'" alt="" loading="lazy"></p><p>这一插件主要用来辅助 <a href="obsidian://show-plugin?id=obsidian-custom-attachment-location" target="_blank" rel="noreferrer">Custom Attachment Location</a> 插件的使用。在经过 <a href="obsidian://show-plugin?id=obsidian-custom-attachment-location" target="_blank" rel="noreferrer">Custom Attachment Location</a> 的命令之后，所有附件被移动到当前文件的父文件夹下，毫无疑问此位置更适合使用相对路径， <code>Vitepress</code> <a href="https://vitepress.dev/zh/guide/asset-handling#referencing-static-assets" target="_blank" rel="noreferrer">官方文档</a> 也是这么建议我们的：</p><p><img src="'+w+'" alt="" loading="lazy"></p><p>因此我们可以利用这一插件进行全局链接的转换，步骤如下：</p><ol><li><p>在 Obsidian 编辑页面，按 <code>Ctrl+p</code> ，换出命令面板；</p></li><li><p>在控制面板输入 <code>Link Converter</code> ，弹出窗口显示如下：</p><p><img src="'+x+`" alt="" loading="lazy"></p><p>选择第二个。</p></li><li><p>等待命令执行完毕即可。</p></li></ol></li></ul><h4 id="文件配置" tabindex="-1">文件配置 <a class="header-anchor" href="#文件配置" aria-label="Permalink to &quot;文件配置&quot;">​</a></h4><p>每一份文件都需要增加 <code>frontmatter</code> 项，基本内容如下：</p><div class="vp-code-block-title"><div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="example.md">example.md</span></div><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">---</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">title:  文章标题</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">createAt:  YYYY-MM-DD HH:mm:ss</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">updateAt:  YYYY-MM-DD HH:mm:ss</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">---</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></div><p>这一配置不仅能够显示文档的历史，也为 <a href="./../🔌功能解耦插件/Vitepress自动生成索引页.html">Vitepress自动生成索引页</a> 提供了方便。这一配置也可以通过插件实现，这里推荐 <a href="obsidian://show-plugin?id=obsidian-linter" target="_blank" rel="noreferrer">Linter</a> 。插件时间戳配置如下：</p><p><img src="`+v+'" alt="" loading="lazy"></p><p>其余默认设置即可。这样你每次创建文件、编辑文件便会自动更新 <code>frontmatter</code> 中的键值对。</p><h3 id="文档编写" tabindex="-1">文档编写 <a class="header-anchor" href="#文档编写" aria-label="Permalink to &quot;文档编写&quot;">​</a></h3><p>在经过了 <a href="#obsidian配置">Obsidian 配置</a> 之后，你就能够按照我的开发模式进行文档撰写了。</p><p>主要开发任务分配给 Obsidian，项目版本控制交给 VScode，并通过浏览器查看 Vitepress 渲染结果。这是一个十分自然的开发过程，快去开启你的愉快探索吧！</p><h2 id="🎊写在最后" tabindex="-1">🎊写在最后 <a class="header-anchor" href="#🎊写在最后" aria-label="Permalink to &quot;🎊写在最后&quot;">​</a></h2><p>可能说「最佳」确实有些标题党，但是不可否认的是，这确实是我体验下来最舒服的书写体验。良好的书写工具和环境无疑会促进你的输出，我个人对现在的状态还是比较满意的。</p><p>如果您对此篇有所建议，欢迎评论留言；如果您愿意贡献此篇，欢迎点击页面右上角 Github 图标，到本仓库提出 <code>PR</code> 。</p>',54)),e(o),e(n)])}const N=d(U,[["render",J]]);export{G as __pageData,N as default};
